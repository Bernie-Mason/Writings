Customising the Prompt

// From "The Linux Command Line" - Chapter 13

In this chapter we will look at the seemingly trivial detail: our shell prompt. This examination will reveal some of the inner workings of the shell and terminal emulator program itself. Like so many things in Linux, the shell prompt is highly comfigurable, and while we have pretty much taken it for granted, the prompt is a really useful device once we learn how to control it.

Anatomy of a Prompt

Our default prompt looks like this:

[bernie@antergos-vbox ~]$

which is

[username@hostname working_directory]

Our prompt is defined by an environmental variable named PS1 (short for prompt string 1). We can view the contents of PS1 with the echo command

[bernie@antergos ~]$ echo $PS1
[\u@\h \W]\$

From the results we can see that PS1 contains a few of the characters we see in our prompt, such as the square brackets, the @ sign, and the dollar sign, and the rest are backslashed escape characters.

Some of characters that the shell treats specially  in the prompt string are:

Sequence	Value Displayed
\a 			ASCII bell
\d 			Current date in day, month, date format
\h 			Hostname of the local machine
\H 			Full hostname
\j 			Number of jobs running in the current shell session
\l 			Name of the current terminal device
\n 			A newline character
\r 			A carriage return
\s 			Name of the shell program
\t 			Current time in 24-hour, hours:minutes:seconds
\T 			Current time in 12 hour
\@			Current time in 12 hour, am/pm 
\A 			Current time in 24 hour, hours:mins
\u 			Username of the current user
\v 			Version number of shell
\V 			Version and release numbers of shell
\w 			Name of the current working directory
\W 			Last part of the current working directory
\! 			History number of the current command
\# 			Number of commands entered in this shell session
\$ 			This displays a $ character unless you have superuser privileges. In that case it displays a # instead
\[ 			This signals the start of a series of one or more non-printing characters. It is used to embed non-printing control characters that manipulate the terminal emulator in some way, such as moving the cursor or changing the text colors.
\] 			This signals the end of a non-printing character sequence

Adding color
Most terminal emulator programs respond to certain non-printing character sequences to control such things as character attributes (like color, bold, text ) and cursor position.

Terminal confusion
Back in ancient times, where terminals were hooked to remote computers, there were many different brands of terminals and they all worked differently. THey had different keyboards, and they all had different ways of interpreting control information. Unix and Unix-like systems have two rather complex subsystems (called termcap and terminfo) to deal with the babel of terminal control.
In an effot to make terminals speak some sort of common language, the ANSI developed a standard set of character sequences to control video terminals. Old-time DOS users will remember the ANSI.SYS file that was used to enable interpretation of these codes.

Character color is controlled by sending the terminal emulator an ANSI escape code embedded in the stream  of characters to be displayed. The control code does not "print out"  on the display; rather it is interpreted by the terminal as an instruction. An ANSI escape code begins with an octal 033 (the code generated by the ESC key), followed by an optional character attribute, followed by an instruction. For example, the code to set the text color to normal (attribute = 0) black text is

\033[0;30m.

The two 0s past the [ change depending on what color you want. Changing the 3 to a 4 changes the background color instead.

Escape codes can be used to position the cursor. THis is commonly used to provide a clock or some kind of information at a different position in the screen (like the upper right corner)