The DefaultControllerFactory class maintains a list of all Controller classes in the application so that it doesn't need to perform a search every time a request arrives. It follows the convention-over-configuration pattern as you don't need to register your controllers in a configuration file, because the factory will find them for you.
This way, you  are able to simply create classes that meet the criteria (public, concrete, end in Controller and inherit from Controller)
Once the controller factory has created an instance of a class, the framework needs a way of invoking an action on that instance. If you derived your controller from the Controller class, then this is the responsibility of an action invoker. The built-in action invoker, the ControllerActionInvoker class, has some sophisticated techniques for matching requests to actions. It also specifically operates on methods although you can create your own which don't have to!
To qualify as an action, a method must meet specific criteria (public, not static, no special name, not present in System.Web.Mvc.Controller or any base classes). Such methods also cannot have generic parameters.
Usually the name of an action method determines the action that it represents. The Index action method services requests for the Index action. This can be overridden using the [ActionName] attribute which changes the expected name for the request. There are two main reasons to do this. 1. You can then accept an action name that wouldn't be legal as a C# method name (like "User-Registration"). 2. If you want to have two different C# methods that accept the same set of parameters and should handle the same action name, but in response to different HTTP request types.
The action invoker uses the action method selectors (like HttpPost and HttpGet) to resolve ambiguity when multiple actions of the same name appear. In addition, the invoker will give preference to actions that have selectors over those that have none. The built in attributes that work as selectors for different kinds of HTTP requests are very commonly used.
The process of selecting an action method:
  1. The action invoker starts with a list of possible candidates, which are controller methods that meet the action method criteria.
  2. The invoker discards any method that has an action method selector attribute that returns false for the current request
  3. If there is exactly one action method with a selector left, then this is the method that is used. If there are more than one method with a selector then an exception is thrown.
  4. If there are no action methods with selectors, then the invoker looks at those without.  If there is exactly one action method without a selector left, then this is the method that is used.

The MVC framework also provides two special kinds of controllers that may improve the performance of your MVC web applications. Like all performance optimizations, these controllers represent compromises, either in ease of use or with reduced functionality.

Sessionless Controllers
By default, controllers support session state, which can be used to store data values across requests, making life easier for the programmer. Creaking and maintaining session state is an involved process. Data must be stored and retrieved, and the sessions themselves must be managed so that they expire appropriately. Session data consumes server memory or space elsewhere and the need to synchronise across multiple Web servers makes it harder to run your application on a server farm.
Not all controllers need session state features however and we can create sessionless controllers: the MVC Framework will not load or store session state when they are used to process a request, and overlapping requests can be processed simultaneously.
A controller factory that implements the IControllerFactory interface directly sets the session state behavior for controllers by returning SessionStateBehavior values from the GetControllerSessionBehvaior method. When using the DefaultControllerFactory you can control the session state by applying the SessionState attribute to individual controller classes, e.g. [SessionState(SessionStateBehaviour.Disabled)]

Asynchronous Controllers:
The underlying ASP.NET platform maintains a pool of .NET threads that are used to process client requests. This pool is called the worker thread pool, and the threads are called worker threads. When a request is received, a worker thread is taken from the pool and given the job of processing the request. When the request has been processed, the worker thread is returned to the pool, so that it is available to process new requests as they arrive.  This has two benefits:
  1. by reusing worker threads, you avoid the overhead of creating a new one every time a request is made.
  2. By having a fixed number of threads available, you avoid the situation where you are processing more simultaneous request than your server can handle.
The worker thread pool works best when requests can be processed in a short period of time. This is the case for most MVC applications. However, if you have actions that depend on other servers and take a long time to complete, then you can reach the point where all your worker threads are tied up waiting for other systems to complete their work.
Your server is capable of doing work but because you have tied up all your worker threads, incoming requests are being queued up. The solution is to use an asynchronous controller. This increases the overall performance of your application, but doesn't bring any of the benefits to the execution of asynchronous operations.
Asychronous controllers are useful only for actions that are I/O or network bound and not CPU intensive. The problem you're trying to solve is a mismatch between the pool model and the type of request you're processing.
