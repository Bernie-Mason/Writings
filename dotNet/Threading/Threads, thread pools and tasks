THREADS, THREADPOOLS AND TASKS

Summary: Task is almost always the best option; it provides a much more powerful API and avoids wasting OS threads. The only reasons to explicitly create your own Threads in modern code are setting per-thread options, or maintaining a persistent thread that needs to maintain its own identity.

In computer science terms, a Task is a future or a promise. Basically, a Task<T> "promises" to return you a T, but not right now.

A Thread is a way of fulfilling that promise. But not every Task needs a brand-new Thread. In fact, creating a thread is often undesirable, because doing so is much more expensive than re-using an existing thread from the threadpool. If the value you are waiting for comes from the filesystem or a database or the network, then there is no need for a thread to sit around and wait for the data when it can be servicing other requests. Instead, the Task might register a callback to receive the value(s) when they're ready.

In particular, the Task does not say why it is that it takes such a long time to return the value. It might be that it takes a long time to compute, or it might that it takes a long time to fetch. Only in the former case would you use a Thread to run a Task. (In .NET, threads are freaking expensive, so you generally want to avoid them as much as possible and really only use them if you want to run multiple heavy computations on multiple CPUs. For example, in Windows, a thread weighs 12 KiByte (I think), in Linux, a thread weighs as little as 4 KiByte, in Erlang/BEAM even just 400 Byte. In .NET, it's 1 MiByte!)

THREAD: The basic unit that an operating system will allocate processing time to. A low level concept. This has it's own stack and kernel resources. In C# this allows high control (Abort(), Suspend(), Resume() etc). Threads are costly with each one consuming a non-trivial amount of memory for its stack, and adds additional CPU overhead as the process context-switches between threads.

THREADPOOL (C#): This is a wrapper around a pool of threads maintained by the CLR. Best used for short operations where the caller doesn't need the result. ThreadPool gives you no control at all; you can submit work to execute at some point, and you can control the size of the pool, but you can't set anything else. This avoids teh overhead of creating too many threads. However, it you submit too many long-running tasks to the threadpool, it can get full, and later work that you submit can end up waiting for the earlier long-running items to finish. In addition, it offers no way to find out when work has been finished. 

TASK (C#): Like the ThreadPool, a task doesn't create it's own OS thread. Instead, tasks are executed by a TaskScheduler; the default scheduler simply runs on the ThreadPool. Task also allows you to find out when it finishes, and (via the generic Task) to return a result. You can call ContinueWith() on an existing Task to make it run more code once the Task finishes. 
You can synchronously wait for a task to finish by calling Wait() (or for a generic task, by getting the Result property). Like Thread.Join(), this will block the calling thread until the ask finishes. This is usually a bad idea; it prevents the calling thread from doing any other work, and can also lead to deadlocks if the task ends up waiting (even async) for the current thread.
Since tasks still run on the ThreadPool, they should not be sued for long-running operations, since they can fill up the thread pool and block new work. Instead, Task provides a LongRunning option, which will tell the TaskScheduler to spin up a new thread rather than running on the ThreadPool. 

All newer high-level concurrency APIs, including the Parallel.For*() methods, PLINQ, await and modern async methods in the BCL are all built on Task.
