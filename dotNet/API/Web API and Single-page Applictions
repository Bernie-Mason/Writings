The Web API feature is a  relatively new feature to the ASP.NET platform that allows you to quickly and easily create Web services that provide an API to HTTP clients, known as Web APIs. This feature is based on the same foundation as the MVC Framework applications, but is not part of the MVC Framework.
Instead Microsoft has taken some key classes and characteristics that are associated with the System.Web.Mvc namespace and associated them with the System.Web.Http namespace. The idea is that Web API is part of the core ASP.NET platform and can be used in other types of Web applications or used as a stand-alone Web services engine. One of the main uses for Web API is to create single-page applications (SPAs) by combining the Web API with MVC Framework features.
Web API simplifies creating Web services.

The term single page application is a broadly applied term. The most consistently-used definition is a web application whose initial content is delivered as a combination of HTML and JavaScript and whose subsequent operations are performed using a RESTful web service that delivers data via JSON in response to Ajax requests.
This differs from the kind of application we've been making, where operations performed by the user result in new HTML documents being generated in response to synchronous HTTP requests, which are called round-trip applications.
The advantages of SPA are that less bandwidth is required and that the user receives a smoother experience. The disadvantage is that the smoother experience can be harder to achieve and that the complexity of the JavaScript code required for a SPA demands careful design and testing. Most applications mix and match SPA and RTA techniques, where each major functional area of the application is delivered as a SPA, and navigation between functional areas is managed using standard HTTP requests that create a new HTML document


Knockjs is a javascript library that microsoft has developed for single-page applications

The Web API feature is based on adding a special kind of controller to an MVC Framework application, called an API Controller. It has two distinct characteristics:
1. Action methods return model, rather than ActionResult, objects
2. Action methods are selected based on HTTP methods used in the request

The model objects that are returned from an API controller action method are encoded as JSON and sent to the client. API controllers are designed to deliver Web data services so they do not support views, layouts or any of the other features we typically use to generate HTML in MVC.

The inability of an API controller to generate HTML from views is the reason that single-page applications combine standard MVC Framework techniques with the Web API. The MVC Framework performs the steps required to deliver HTML content to the user (including authentication, authorization and selecting and rendering a view). Once HTML is delivered to the browser, the Ajax requests generated by the JavaScript it contains are handled by the Web API controller.

public class WebController : ApiController
{
    private ReservationRepository repo = ReservationRepository.Current;

    public IEnumerable<Reservation> GetAllReservations()
    {
        return repo.GetAll();
    }

    public Reservation GetReservation(int id)
    {
        return repo.Get(id);
    }

    public Reservation PostReservation(Reservation item)
    {
        return repo.Add(item);
    }

    public bool PutReservation(Reservation item)
    {
        return repo.Update(item);
    }

    public void DeleteReservation(int id)
    {
        repo.Remove(id);
    }
}

API controllers have their own routing that is completely separate from the rest of the application.

public static void Register(HttpConfiguration config)
{
    // Web API configuration and services

    // Web API routes
    config.MapHttpAttributeRoutes();

    config.Routes.MapHttpRoute(
        name: "DefaultApi",
        routeTemplate: "api/{controller}/{id}",
        defaults: new { id = RouteParameter.Optional }
    );
}

Note that it uses different classes from the regular MVC routes defined in the RouteConfig.cs file. Visual studio also adds a call from the Application_Start method in the Global.asax class so that the Web API routes are added to the application configuration.

API Controller Action Selection
The key difference from a regular MVC route is that there is no action segment variable. When a request comes in to the application that matches a Web API route, the action is determined from the HTTP method used to make the request. The convention when naming API controller action methods is to prefix the name with the action method that it supports and include some reference to the model type that it operates. This is just a convention because Web API will match any action method whose name CONTAINS the HTTP method used to make the request (like DELETE, PUT, GET etc). So GET results in a choice between GetAllReservations and GetReservation but method names like DoGetReservation or ThisIsTheGetAction would also be matched.
To decide between two action methods, the controller looks at the arguments that the contenders accept and uses the routing variables to make the best match. When requesting /api/reservation API, there were no routing variables expect for controller, and so the GetAllReservations method is selected because it has no arguments. When requesting /api/reservation/3, the optional id segment makes the GetReservation a better match.

Note: REST is a style of API rather than a well-defined specification, and there is disagreement about what exactly makes a Web service RESTful. One point of contention is that purist do not consider Web services that return JSON as being RESTful.

Mapping HTTP methods to Action Methods
Instead of having rather ill-fitting and clunky names such as PutReservation we can use HTTP attributes instead and use more logical names:

...
[HttpPost]
public Reservation CreateReservation(Reservation item)
{
    return repo.Add(item);
}

[HttpPut]
public bool UpdateReservation(Reservation item)
{
    return repo.Update(item);
}
...

Here we can see the duplication from the MVC Framework features. Allowing us to add HTTP attributes in the same way we would MVC controllers.

The purpose of creating the Web API web service is allow operations on application data to be performed using Ajax requests whose JSON results will be used to update the HTML in the browser. The transition to a single-page application puts more of a burden on the browser because we need to preserve the application state at the client. We need a data model that we can update, a series of logic operations we can perform to transform the data and a set of UI elements that allows the user to trigger those operations. We can use the knockout.js library to perform this work.

Our Index page (styles and script referenced in the layout) now looks like this:

@using WebServices.Models
@model IEnumerable<Reservation>
@{
    ViewBag.Title = "Index";
}

<h2>Index</h2>

@section Scripts{
    <script>
        var model = {
            reservations: ko.observableArray()
        }

        function sendAjaxRequest(httpMethod, callback, url)
        {
            $.ajax("/api/web" + (url ? "/" + url : ""),
            {
                type: httpMethod,
                success: callback
            });
        }

        function getAllItems() {
            sendAjaxRequest("GET",
                function(data) {
                    model.reservations.removeAll();
                    for (var i = 0; i < data.length; i++) {
                        model.reservations.push(data[i]);
                    }
                });
        }

        function removeItem(item) {
            sendAjaxRequest("DELETE",
                function() {
                    getAllItems();
                },
                item.ReservationId);
        }

        $(document).ready(function() {
            getAllItems();
            ko.applyBindings(model);
        });

    </script>
}

@section Body{
    <div id="summary" class="section panel panel-primary">
        <div class="panel-heading">Reservation Summary</div>
        <div class="panel-body">
            <table class="table table-striped table-condensed">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Name</th>
                        <th>Location</th>
                    </tr>
                </thead>
                <tbody data-bind="foreach: model.reservations">
                    {
                        <tr>
                            <td data-bind>"text: ReservationId"</td>
                            <td data-bind>"text: ClientName"</td>
                            <td data-bind>"text: Location"</td>
                            <td><button class="btn btn-primary btn-xs" data-bind="click: removeItem">
                                Remove
                            </button></td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    </div>
}

There's a ton going on here!

First let's look at the sendAjaxRequest function:

function sendAjaxRequest(httpMethod, callback, url)
{
    $.ajax("/api/web" + (url ? "/" + url : ""),
    {
        type: httpMethod,
        success: callback
    });
}

The $.ajax function provides access to the jQuery Ajax functionality. The arguments are the URL you want to request and an object that contains configuration parameters. The sendAjaxRequest function is a wrapper around the jQuery functionality and its arguments are the HTTP method that should be used for the request (which affects the action method selected by the controller)
Using the sendAjaxFunction as a foundation we defined functions to get all of the data available and to delete a reservation:

function getAllItems() {
    sendAjaxRequest("GET",
        function(data) {
            model.reservations.removeAll();
            for (var i = 0; i < data.length; i++) {
                model.reservations.push(data[i]);
            }
        });
}

function removeItem(item) {
    sendAjaxRequest("DELETE",
        function() {
            getAllItems();
        },
        item.ReservationId);
}

Underpinning the Ajax functions is the model which we defined:

var model = {
    reservations: ko.observableArray()
}

Knockout works by creating observable objects that it monitors for changes and uses to update the HTML displayed by the browser. The above model is simple, and consists of an observable array, which is just like a JavaScript array but is wired up so that any changes I made are detected by Knockout.

Knockout applies changes in the data model to HTML elements via data bindings:

<tbody data-bind="foreach: model.reservations">
    {
        <tr>
            <td data-bind>"text: ReservationId"</td>
            <td data-bind>"text: ClientName"</td>
            <td data-bind>"text: Location"</td>
            <td><button class="btn btn-primary btn-xs" data-bind="click: removeItem">
                Remove
            </button></td>
        </tr>
    }
</tbody>

Knockout is expressed using the data-bind attribute and there is a wide range of bindings available. The types used here.  The foreach binding, Knockout generates child elements for each object in the expression. The text binding inserts the value of the expression as the text of the element that it is applied to. The click directive is different: it sets up an event handler for the click event on the element to which it has been applied.

Knockout bindings are not automatically processed which is why we included:

$(document).ready(function() {
    getAllItems();
    ko.applyBindings(model);
});

The $(document).ready call is a standard jQuery technique to defer exectuion of a function until all of the HTML elements in the document have loaded and processed by the browser. Once that happens, I call the getAllItems function to load the data from the server and the ko.applyBindings function to use the data model to process the data-bind attributes. The final call is the one that connects the data objects to the HTML elements, generates the content I require and sets up the event handlers.

To create the editor, I have used Knockout in a different way:

...

@section Scripts{
    <script>
        var model = {
            reservations: ko.observableArray(),
            editor: {
                name: ko.observable(""),
                location: ko.observable("")
            }
        }

        ...

        function handleEditorClick() {
            sendAjaxRequest("POST",
                function(newItem) {
                    model.reservations.push(newItem);
                },
                null,
                { ClientName: model.editor.name, Location: model.editor.location });
        }

        $(document).ready(function() {
            getAllItems();
            ko.applyBindings(model);
        });

    </script>
}

@section Body{
    <div id="summary" class="section panel panel-primary">
        <div class="panel-heading">Reservation Summary</div>
          ...
        </div>
    </div>
    <div id="editor" class="section panel panel-primary">
        <div class="panel-heading">Create Reservation</div>
        <div class="panel-body">
                <div class="form-group">
                    <label>ClientName: </label>
                    <input class="form-control" data-bind="value: model.editor.name"/>
                </div>
                <div class="form-group">
                    <label>Location: </label>
                    <input class="form-control" data-bind="value: model.editor.location" />
                </div>
                <button class ="btn btn-primary" data-bind="click: handleEditorClick">Save</button>
        </div>

    </div>
}


First we have extended the model so that we define the variables that we can use to capture the ClientName and Location values:

var model = {
    reservations: ko.observableArray(),
    editor: {
        name: ko.observable(""),
        location: ko.observable("")
    }
}

The ko.observable function creates an observable value, which we will rely on later.

We then implment the input elements: <input class="form-control" data-bind="value: model.editor.name"/>
